@using DMB.Core
@using System.Drawing
@using DMB.Core.Evaluator

@inject ExpressionEvaluator Evaluator

<div class="@($"dmr-cell {Cell.Class}")"
     style="@BuildCellStyle()"
     id="@Cell.Id">

    @if (Cell.Element is GridModelCore subGrid)
    {
        <GridRenderer Grid="subGrid" />
    }
    else if (Cell.Element is not null && IsVisible(Cell.Element))
    {
        <ElementRenderer Element="Cell.Element" />
    }

</div>

@code {
    [Parameter, EditorRequired]
    public CellModelCore Cell { get; set; } = default!;

    public bool IsVisible(ElementModel element)
    {
        try
        {
            var value = ExpressionablePropertyResolver<bool>.Resolve(element.Visible, Evaluator);
            return value;
        }
        catch
        {
            throw;
        }
    }

    private string BuildCellStyle()
    {
        // preserve user style + add alignment rules
        var baseStyle = Cell.Style?.Trim();
        if (!string.IsNullOrEmpty(baseStyle) && !baseStyle.EndsWith(";"))
            baseStyle += ";";

        var jc = ToJustifyContent(Cell.HorizontalAlignment);
        var ai = ToAlignItems(Cell.VerticalAlignment);

        return $"{baseStyle}display:flex;width:100%;height:100%;justify-content:{jc};align-items:{ai};";
    }

    private static string ToJustifyContent(ContentAlignment a) => a switch
    {
        ContentAlignment.Start => "flex-start",
        ContentAlignment.Center => "center",
        ContentAlignment.End => "flex-end",
        _ => "flex-start"
    };

    private static string ToAlignItems(ContentAlignment a) => a switch
    {
        ContentAlignment.Start => "flex-start",
        ContentAlignment.Center => "center",
        ContentAlignment.End => "flex-end",
        _ => "flex-start"
    };
}